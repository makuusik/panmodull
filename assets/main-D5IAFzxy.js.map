{"version":3,"file":"main-D5IAFzxy.js","sources":["../../src/script/main.js"],"sourcesContent":["// document.addEventListener('DOMContentLoaded', function () {\n//   const svgObject = document.getElementById('svg-object');\n\n//   svgObject.addEventListener('load', function () {\n//     const svgDoc = svgObject.contentDocument; // Отримуємо доступ до внутрішнього SVG документа\n//     const paths = svgDoc.querySelectorAll('path'); // Вибираємо всі елементи path в SVG\n\n//     paths.forEach(path => {\n//       path.style.strokeDasharray = path.getTotalLength(); // Встановлюємо довжину для кожного path\n//       path.style.strokeDashoffset = path.getTotalLength(); // Сховуємо лінію\n//       path.classList.add('draw'); // Додаємо клас для анімації\n//     });\n//   });\n// });\n// document.addEventListener('DOMContentLoaded', function () {\n//   const imageGrid = document.querySelector('.image-grid');\n//   const images = document.querySelectorAll('.image-wrapper');\n\n//   function updateImageOpacity() {\n//     const gridRect = imageGrid.getBoundingClientRect();\n//     const gridCenter = gridRect.left + gridRect.width / 2;\n\n//     images.forEach(image => {\n//       const rect = image.getBoundingClientRect();\n//       const imageCenter = rect.left + rect.width / 2;\n//       const distance = Math.abs(gridCenter - imageCenter);\n//       const maxDistance = gridRect.width / 2;\n\n//       // Обчислення прозорості залежно від відстані\n//       let opacity = Math.max(0.3, 1 - distance / maxDistance);\n//       image.style.opacity = opacity;\n//     });\n//   }\n\n//   imageGrid.addEventListener('scroll', updateImageOpacity);\n//   window.addEventListener('resize', updateImageOpacity);\n\n//   updateImageOpacity();\n// });\n// window.onload = function () {\n//   window.scrollGallery = function (direction) {\n//     const container = document.querySelector('.image-grid');\n//     const scrollAmount = container.clientWidth * 0.5; // Прокрутка на 50% ширини\n//     container.scrollBy({\n//       left: direction * scrollAmount,\n//       behavior: 'smooth',\n//     });\n//   };\n// };\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  const svgObject = document.getElementById('svg-object');\n\n  if (svgObject) {\n    svgObject.addEventListener('load', function () {\n      const svgDoc = svgObject.contentDocument;\n      const paths = svgDoc.querySelectorAll('path');\n\n      paths.forEach(path => {\n        path.style.strokeDasharray = path.getTotalLength();\n        path.style.strokeDashoffset = path.getTotalLength();\n        path.classList.add('draw');\n      });\n    });\n  }\n});\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  const imageGrid = document.querySelector('.image-grid');\n  const images = document.querySelectorAll('.image-wrapper');\n\n  // Оновлення прозорості зображень\n  function updateImageOpacity() {\n    if (window.innerWidth > 768) {\n      // Якщо не телефон, скидаємо прозорість і виходимо\n      images.forEach(image => (image.style.opacity = 1));\n      return;\n    }\n\n    const gridRect = imageGrid.getBoundingClientRect();\n    const gridCenter = gridRect.left + gridRect.width / 2;\n\n    images.forEach(image => {\n      const rect = image.getBoundingClientRect();\n      const imageCenter = rect.left + rect.width / 2;\n      const distance = Math.abs(gridCenter - imageCenter);\n      const maxDistance = gridRect.width / 2;\n\n      let opacity = Math.max(0.3, 1 - distance / maxDistance);\n      image.style.opacity = opacity;\n    });\n  }\n\n  imageGrid.addEventListener('scroll', updateImageOpacity);\n  window.addEventListener('resize', updateImageOpacity);\n\n  updateImageOpacity();\n});\n\ndocument.addEventListener('DOMContentLoaded', function () {\n  const container = document.querySelector('.image-grid');\n\n  if (container) {\n    // Примусово змушуємо контейнер ініціалізувати скрол\n    container.scrollLeft = 1;\n    container.scrollLeft = 0;\n\n    if (window.innerWidth < 768) {\n      Object.assign(container.style, {\n        display: 'flex',\n        overflowX: 'scroll',\n        scrollSnapType: 'x mandatory',\n        scrollBehavior: 'smooth',\n      });\n    }\n\n    // Функція для прокручування\n    window.scrollGallery = function (direction) {\n      const scrollAmount = container.clientWidth * 0.5; // Прокручування на 50% ширини\n\n      setTimeout(() => {\n        container.scrollBy({\n          left: direction * scrollAmount, // Використовуємо 'left' для горизонтального скролу\n          behavior: 'smooth',\n        });\n      }, 50);\n    };\n\n    // Додаємо обробники подій для кнопки\n    document.querySelectorAll('.scroll-btn').forEach(btn => {\n      const direction = btn.classList.contains('left') ? -1 : 1;\n\n      // Клік на кнопку\n      btn.addEventListener('click', () => window.scrollGallery(direction));\n\n      // Для мобільних пристроїв використаємо touchstart\n      btn.addEventListener('touchstart', e => {\n        e.preventDefault(); // Запобігає дублюванню події\n        window.scrollGallery(direction);\n      });\n\n      // Додатково можна додати обробник touchend, щоб зменшити дублювання\n      btn.addEventListener('touchend', () => window.scrollGallery(direction));\n    });\n  }\n});\n\n// window.onload = function () {\n//   window.scrollGallery = function (direction) {\n//     const container = document.querySelector('.image-grid');\n//     const scrollAmount = container.clientWidth * 0.5;\n\n//     container.scrollBy({\n//       left: direction * scrollAmount,\n//       behavior: 'smooth',\n//     });\n//   };\n// };\n// document.addEventListener('DOMContentLoaded', () => {\n//   const container = document.querySelector('.image-grid');\n\n//   if (container) {\n//     // Примусово змушуємо контейнер ініціалізувати скрол\n//     container.scrollLeft = 1;\n//     container.scrollLeft = 0;\n//     if (window.innerWidth < 768) {\n//       Object.assign(container.style, {\n//         display: 'flex',\n//         overflowX: 'scroll',\n//         scrollSnapType: 'x mandatory',\n//         scrollBehavior: 'smooth',\n//       });\n//     }\n\n//     // Додаємо стилі динамічно\n\n//     window.scrollGallery = function (direction) {\n//       const scrollAmount = container.clientWidth * 0.5;\n\n//       setTimeout(() => {\n//         container.scrollBy({\n//           left: direction * scrollAmount,\n//           behavior: 'smooth',\n//         });\n//       }, 50);\n//     };\n//   }\n// });\n"],"names":["svgObject","path","imageGrid","images","updateImageOpacity","image","gridRect","gridCenter","rect","imageCenter","distance","maxDistance","opacity","container","direction","scrollAmount","btn","e"],"mappings":"AAkDA,SAAS,iBAAiB,mBAAoB,UAAY,CACxD,MAAMA,EAAY,SAAS,eAAe,YAAY,EAElDA,GACFA,EAAU,iBAAiB,OAAQ,UAAY,CAC9BA,EAAU,gBACJ,iBAAiB,MAAM,EAEtC,QAAQC,GAAQ,CACpBA,EAAK,MAAM,gBAAkBA,EAAK,eAAc,EAChDA,EAAK,MAAM,iBAAmBA,EAAK,eAAc,EACjDA,EAAK,UAAU,IAAI,MAAM,CACjC,CAAO,CACP,CAAK,CAEL,CAAC,EAED,SAAS,iBAAiB,mBAAoB,UAAY,CACxD,MAAMC,EAAY,SAAS,cAAc,aAAa,EAChDC,EAAS,SAAS,iBAAiB,gBAAgB,EAGzD,SAASC,GAAqB,CAC5B,GAAI,OAAO,WAAa,IAAK,CAE3BD,EAAO,QAAQE,GAAUA,EAAM,MAAM,QAAU,CAAE,EACjD,MACD,CAED,MAAMC,EAAWJ,EAAU,wBACrBK,EAAaD,EAAS,KAAOA,EAAS,MAAQ,EAEpDH,EAAO,QAAQE,GAAS,CACtB,MAAMG,EAAOH,EAAM,wBACbI,EAAcD,EAAK,KAAOA,EAAK,MAAQ,EACvCE,EAAW,KAAK,IAAIH,EAAaE,CAAW,EAC5CE,EAAcL,EAAS,MAAQ,EAErC,IAAIM,EAAU,KAAK,IAAI,GAAK,EAAIF,EAAWC,CAAW,EACtDN,EAAM,MAAM,QAAUO,CAC5B,CAAK,CACF,CAEDV,EAAU,iBAAiB,SAAUE,CAAkB,EACvD,OAAO,iBAAiB,SAAUA,CAAkB,EAEpDA,GACF,CAAC,EAED,SAAS,iBAAiB,mBAAoB,UAAY,CACxD,MAAMS,EAAY,SAAS,cAAc,aAAa,EAElDA,IAEFA,EAAU,WAAa,EACvBA,EAAU,WAAa,EAEnB,OAAO,WAAa,KACtB,OAAO,OAAOA,EAAU,MAAO,CAC7B,QAAS,OACT,UAAW,SACX,eAAgB,cAChB,eAAgB,QACxB,CAAO,EAIH,OAAO,cAAgB,SAAUC,EAAW,CAC1C,MAAMC,EAAeF,EAAU,YAAc,GAE7C,WAAW,IAAM,CACfA,EAAU,SAAS,CACjB,KAAMC,EAAYC,EAClB,SAAU,QACpB,CAAS,CACF,EAAE,EAAE,CACX,EAGI,SAAS,iBAAiB,aAAa,EAAE,QAAQC,GAAO,CACtD,MAAMF,EAAYE,EAAI,UAAU,SAAS,MAAM,EAAI,GAAK,EAGxDA,EAAI,iBAAiB,QAAS,IAAM,OAAO,cAAcF,CAAS,CAAC,EAGnEE,EAAI,iBAAiB,aAAcC,GAAK,CACtCA,EAAE,eAAc,EAChB,OAAO,cAAcH,CAAS,CACtC,CAAO,EAGDE,EAAI,iBAAiB,WAAY,IAAM,OAAO,cAAcF,CAAS,CAAC,CAC5E,CAAK,EAEL,CAAC"}